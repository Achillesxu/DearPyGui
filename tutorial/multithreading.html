<!doctype html>
<html lang="en">
<script type="text/javascript" src="tutorial-injection.js"></script>

    <article><a name="multithreading"></a>
        <h2>Multithreading & Asynchronous Functions</h2>
        <hr>
        <p>
            For calculations and callbacks that require extended time it can be useful to implement asynchronous functions or functions ran on separate threads.
            To do this simply call <i>run_async_function</i>.
            <br><br>
            It is important to note that functions ran with the async command can only call certain <i>Dear PyGui</i> commands (get_value, set_value, add_data, get_data).
        </p>
        <pre><code data-language="python">from dearpygui.core import *
from dearpygui.simple import *
from time import sleep

def long_async_callback(data, sender):
    run_async_function(long_callback, None)

def long_callback(sender, data):
    sleep(3)

show_logger()
show_metrics()

with window("Tutorial"):
    add_button("long function", callback=long_callback, tip="This will cause a 3 second freeze")
    add_button("long Asynchronous Function", callback=long_async_callback, tip="This will not freeze")

start_dearpygui()</code></pre>
        <p>
            Asynchronous functions cannot access <i>add_data</i>
            or <i>get_data</i>. So when it is necessary to pass data to the asynchronous
            function you must use the data and return handler keyworded arguments.
            Any Python object can be made accessible the the async function by being sent into the function through the "data" keyword.
            Additionally, any returned data from the Async function will be accessible through the "data" input of the specified return callback.
        </p>
        <pre><code data-language="python">from dearpygui.core import *
from dearpygui.simple import *
from time import sleep

def long_async_preparer(data, sender):
    floaty = get_value("Async Input Data")
    run_async_function(long_callback, floaty, return_handler=long_async_return)

def long_callback(sender, data):
    sleep(3)
    return data * 2

def long_async_return(sender, data):
    log_debug(data)

def long_callback2(sender, data):
    sleep(3)
    log_debug(data * 2)

show_logger()

with window("Tutorial"):
    add_text("Input a number and see the logger window for the output of the long callback that would normally freeze the GUI")
    add_input_float("Async Input Data", default_value=1.0)
    add_button("long Function", callback=long_callback2, callback_data=get_value("Async Input Data"), tip="This is the long callback that will freeze the GUI")
    add_button("long Asynchronous Function", callback=long_async_preparer, tip="This will not freeze the GUI")

start_dearpygui()</code></pre>
        <p>
            When the asynchronous function method is called a thread pool is created. The aspects of the thread pool that
            can be configured are the number of threads and the timeout time.
            <br><br>
            using <i>set_thread_count</i> we can set the number of threads in the thread pool.
            Also we can use <i>set_threadpool_high_performance</i> to tell the thread pool to
            max out the number of threads per the users computer. Be aware that this will run the CPU at 100% when calling async functions.
            <br><br>
            Setting the timeout time for the thread pool can be done using <i>set_threadpool_timeout</i>.
            This will destroy the thread pool and free the resources after the set amount of time.
        </p>
    </article>
</html>